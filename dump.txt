===== FILE: D:\DATA\Kd\PJ11\Heart Beats\HeartBeats\HeartBeats\App.xaml =====
<Application x:Class="HeartBeats.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             StartupUri="MainWindow.xaml">
    <Application.Resources>

        <!-- Dark ContextMenu -->
        <Style TargetType="{x:Type ContextMenu}">
            <Setter Property="SnapsToDevicePixels" Value="True"/>
            <Setter Property="OverridesDefaultStyle" Value="True"/>
            <Setter Property="HasDropShadow" Value="True"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="{x:Type ContextMenu}">
                        <Border Background="#F21C1F22"
                                BorderBrush="#33FFFFFF"
                                BorderThickness="1"
                                CornerRadius="10"
                                Padding="6"
                                SnapsToDevicePixels="True">
                            <StackPanel IsItemsHost="True"
                                        KeyboardNavigation.DirectionalNavigation="Cycle"/>
                        </Border>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>

        <!-- Dark MenuItem -->
        <Style TargetType="{x:Type MenuItem}">
            <Setter Property="SnapsToDevicePixels" Value="True"/>
            <Setter Property="Foreground" Value="#CCFFFFFF"/>
            <Setter Property="Background" Value="Transparent"/>
            <Setter Property="Padding" Value="10,6"/>
            <Setter Property="Margin" Value="2,1"/>
            <Setter Property="FontSize" Value="13"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="{x:Type MenuItem}">
                        <Border x:Name="Outer"
                                Background="{TemplateBinding Background}"
                                CornerRadius="8"
                                Padding="{TemplateBinding Padding}">
                            <Grid>
                                <Grid.ColumnDefinitions>
                                    <ColumnDefinition Width="28"/>
                                    <ColumnDefinition Width="*"/>
                                </Grid.ColumnDefinitions>

                                <!-- Rounded checkbox area -->
                                <Border x:Name="CheckBoxBorder"
                                        Width="18" Height="18"
                                        CornerRadius="6"
                                        BorderThickness="1"
                                        BorderBrush="Transparent"
                                        Background="Transparent"
                                        VerticalAlignment="Center"
                                        HorizontalAlignment="Center">
                                    <Path x:Name="CheckMark"
                                          Data="M 3 9 L 7 13 L 15 4"
                                          Stroke="#E6FFFFFF"
                                          StrokeThickness="2"
                                          StrokeStartLineCap="Round"
                                          StrokeEndLineCap="Round"
                                          Visibility="Collapsed"/>
                                </Border>

                                <!-- Text (显式绑定前景色) -->
                                <ContentPresenter Grid.Column="1"
                                                  ContentSource="Header"
                                                  RecognizesAccessKey="True"
                                                  VerticalAlignment="Center"
                                                  TextElement.Foreground="{TemplateBinding Foreground}"/>
                            </Grid>
                        </Border>

                        <ControlTemplate.Triggers>
                            <Trigger Property="IsEnabled" Value="False">
                                <Setter Property="Foreground" Value="#66FFFFFF"/>
                            </Trigger>

                            <Trigger Property="IsHighlighted" Value="True">
                                <Setter TargetName="Outer" Property="Background" Value="#22FFFFFF"/>
                            </Trigger>

                            <Trigger Property="IsChecked" Value="True">
                                <Setter Property="Foreground" Value="#E6FFFFFF"/>
                                <Setter TargetName="CheckBoxBorder" Property="BorderBrush" Value="#66FFFFFF"/>
                                <Setter TargetName="CheckMark" Property="Visibility" Value="Visible"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>

        <!-- Separator style (更浅) -->
        <Style TargetType="{x:Type Separator}">
            <Setter Property="Margin" Value="6,4"/>
            <Setter Property="Background" Value="#14FFFFFF"/>
            <Setter Property="Height" Value="1"/>
        </Style>

    </Application.Resources>
</Application>


----- END FILE -----

===== FILE: D:\DATA\Kd\PJ11\Heart Beats\HeartBeats\HeartBeats\App.xaml.cs =====
using System.Configuration;
using System.Data;
using System.Windows;

namespace HeartBeats
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application
    {
    }

}


----- END FILE -----

===== FILE: D:\DATA\Kd\PJ11\Heart Beats\HeartBeats\HeartBeats\AssemblyInfo.cs =====
using System.Windows;

[assembly: ThemeInfo(
    ResourceDictionaryLocation.None,            //where theme specific resource dictionaries are located
                                                //(used if a resource is not found in the page,
                                                // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly   //where the generic resource dictionary is located
                                                //(used if a resource is not found in the page,
                                                // app, or any theme specific resource dictionaries)
)]


----- END FILE -----

===== FILE: D:\DATA\Kd\PJ11\Heart Beats\HeartBeats\HeartBeats\BleHeartRateClient.cs =====
using System;
using System.Linq;
using System.Threading.Tasks;
using Windows.Devices.Bluetooth;
using Windows.Devices.Bluetooth.GenericAttributeProfile;
using Windows.Storage.Streams;

namespace HeartBeats;

public sealed class BleHeartRateClient
{
    private static readonly Guid HrService = Guid.Parse("0000180D-0000-1000-8000-00805F9B34FB");
    private static readonly Guid HrMeasurement = Guid.Parse("00002A37-0000-1000-8000-00805F9B34FB");

    private BluetoothLEDevice? _dev;
    private GattCharacteristic? _hrChar;

    public event Action<int>? OnBpm;
    public event Action<string>? OnStatus;

    public async Task ConnectAndSubscribeAsync(string mac)
    {
        OnStatus?.Invoke("CONNECTING");

        ulong address = ParseMacToUlong(mac);
        _dev = await BluetoothLEDevice.FromBluetoothAddressAsync(address);

        if (_dev == null) { OnStatus?.Invoke("DEVICE NULL"); return; }

        var svcResult = await _dev.GetGattServicesForUuidAsync(HrService, BluetoothCacheMode.Uncached);
        var svc = svcResult.Services.FirstOrDefault();
        if (svc == null) { OnStatus?.Invoke("NO HR SERVICE"); return; }

        var chResult = await svc.GetCharacteristicsForUuidAsync(HrMeasurement, BluetoothCacheMode.Uncached);
        _hrChar = chResult.Characteristics.FirstOrDefault();
        if (_hrChar == null) { OnStatus?.Invoke("NO HR CHAR"); return; }

        _hrChar.ValueChanged += HrCharOnValueChanged;

        var status = await _hrChar.WriteClientCharacteristicConfigurationDescriptorAsync(
            GattClientCharacteristicConfigurationDescriptorValue.Notify);

        OnStatus?.Invoke(status == GattCommunicationStatus.Success ? "LIVE" : $"SUB FAIL:{status}");
    }

    public async Task DisconnectAsync()
    {
        if (_hrChar != null)
        {
            _hrChar.ValueChanged -= HrCharOnValueChanged;
            try
            {
                await _hrChar.WriteClientCharacteristicConfigurationDescriptorAsync(
                    GattClientCharacteristicConfigurationDescriptorValue.None);
            }
            catch { }
        }

        _hrChar = null;
        _dev?.Dispose();
        _dev = null;
        OnStatus?.Invoke("DISCONNECTED");
    }

    private void HrCharOnValueChanged(GattCharacteristic sender, GattValueChangedEventArgs args)
    {
        var data = new byte[args.CharacteristicValue.Length];
        DataReader.FromBuffer(args.CharacteristicValue).ReadBytes(data);

        int bpm = ParseBpm(data);
        if (bpm > 0) OnBpm?.Invoke(bpm);
    }

    private static int ParseBpm(byte[] data)
    {
        if (data == null || data.Length < 2) return -1;

        int flags = data[0] & 0xFF;
        bool is16 = (flags & 0x01) != 0;

        if (!is16) return data[1] & 0xFF;
        if (data.Length < 3) return -1;

        return (data[1] & 0xFF) | ((data[2] & 0xFF) << 8);
    }

    private static ulong ParseMacToUlong(string mac)
    {
        string hex = mac.Replace(":", "").Replace("-", "").Trim();
        return Convert.ToUInt64(hex, 16);
    }
}


----- END FILE -----

===== FILE: D:\DATA\Kd\PJ11\Heart Beats\HeartBeats\HeartBeats\HeartBeats.csproj =====
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>WinExe</OutputType>
	 <TargetFramework>net10.0-windows10.0.19041.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <UseWPF>true</UseWPF>
  </PropertyGroup>

</Project>


----- END FILE -----

===== FILE: D:\DATA\Kd\PJ11\Heart Beats\HeartBeats\HeartBeats\HudSettings.cs =====
using System;
using System.IO;
using System.Text.Json;

namespace HeartBeats;

public sealed class HudSettings
{
    // 用像素保存（避免不同缩放导致的 Top/Y 漂移）
    public int Xpx { get; set; } = int.MinValue;
    public int Ypx { get; set; } = int.MinValue;
    public bool Collapsed { get; set; } = false;

    // 0=Off, 1=Minimal(简洁), 2=Ticks(刻度)
    public int GridMode { get; set; } = 1;

    // 曲线显示窗口（秒）
    public int ChartWindowSeconds { get; set; } = 60;

    public static string SettingsPath =>
        Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
            "HeartBeats", "settings.json");

    public static HudSettings Load()
    {
        try
        {
            if (!File.Exists(SettingsPath)) return new HudSettings();
            var json = File.ReadAllText(SettingsPath);
            return JsonSerializer.Deserialize<HudSettings>(json) ?? new HudSettings();
        }
        catch
        {
            return new HudSettings();
        }
    }

    public void Save()
    {
        try
        {
            Directory.CreateDirectory(Path.GetDirectoryName(SettingsPath)!);
            var json = JsonSerializer.Serialize(this, new JsonSerializerOptions { WriteIndented = true });
            File.WriteAllText(SettingsPath, json);
        }
        catch { }
    }
}


----- END FILE -----

===== FILE: D:\DATA\Kd\PJ11\Heart Beats\HeartBeats\HeartBeats\MainWindow.xaml =====
<Window x:Class="HeartBeats.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="HR HUD"
        Width="260" Height="260"
        Topmost="True"
        WindowStartupLocation="Manual"
        ResizeMode="NoResize"
        Background="Transparent"
        AllowsTransparency="True"
        WindowStyle="None"
        ShowInTaskbar="True"
        UseLayoutRounding="True"
        SnapsToDevicePixels="True"
        TextOptions.TextFormattingMode="Display">

    <Border x:Name="Card"
            CornerRadius="16"
            Background="#F21C1F22"
            BorderBrush="#33FFFFFF"
            BorderThickness="1"
            Padding="14"
            SnapsToDevicePixels="True"
            MouseLeftButtonDown="Card_MouseLeftButtonDown"
            MouseLeftButtonUp="Card_MouseLeftButtonUp"
            ContextMenuOpening="Card_ContextMenuOpening">

        <Border.ContextMenu>
            <ContextMenu>
                <MenuItem Header="Grid / 网格" IsEnabled="False"/>
                <MenuItem x:Name="GridOffItem" Header="Off / 关闭" Click="GridOff_Click"/>
                <MenuItem x:Name="GridMinimalItem" Header="Minimal / 简洁" Click="GridMinimal_Click"/>
                <MenuItem x:Name="GridTicksItem" Header="Ticks / 刻度" Click="GridTicks_Click"/>

                <Separator/>

                <MenuItem Header="Window / 时间窗" IsEnabled="False"/>
                <MenuItem x:Name="Win30Item" Header="30s" Click="Win30_Click"/>
                <MenuItem x:Name="Win60Item" Header="60s" Click="Win60_Click"/>
                <MenuItem x:Name="Win120Item" Header="120s" Click="Win120_Click"/>
            </ContextMenu>
        </Border.ContextMenu>

        <Grid>
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="*"/>
            </Grid.RowDefinitions>

            <!-- 顶部栏 -->
            <Grid Grid.Row="0">
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="Auto"/>
                    <ColumnDefinition Width="*"/>
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>

                <TextBlock Text="❤️" FontSize="16" VerticalAlignment="Center"/>

                <TextBlock Grid.Column="1"
                           Text="HR HUD"
                           Margin="8,0,0,0"
                           Foreground="#CCFFFFFF"
                           FontWeight="SemiBold"
                           VerticalAlignment="Center"/>

                <Button Grid.Column="2"
                        x:Name="ToggleBtn"
                        Width="30" Height="30"
                        Click="ToggleBtn_Click"
                        Background="#22FFFFFF"
                        Foreground="White"
                        BorderBrush="#33FFFFFF"
                        BorderThickness="1"
                        Focusable="False"
                        FocusVisualStyle="{x:Null}">
                    <Button.Template>
                        <ControlTemplate TargetType="Button">
                            <Border x:Name="b"
                                    Background="{TemplateBinding Background}"
                                    BorderBrush="{TemplateBinding BorderBrush}"
                                    BorderThickness="{TemplateBinding BorderThickness}"
                                    CornerRadius="15">
                                <!-- 圆角箭头图标（居中） -->
                                <Path x:Name="arrow"
                                      Data="M 0,0 L 5,5 L 10,0"
                                      Stroke="White"
                                      StrokeThickness="2"
                                      StrokeStartLineCap="Round"
                                      StrokeEndLineCap="Round"
                                      StrokeLineJoin="Round"
                                      Width="10" Height="5"
                                      Stretch="None"
                                      HorizontalAlignment="Center"
                                      VerticalAlignment="Center"/>
                            </Border>
                            <ControlTemplate.Triggers>
                                <Trigger Property="IsMouseOver" Value="True">
                                    <Setter TargetName="b" Property="Background" Value="#33FFFFFF"/>
                                </Trigger>
                                <Trigger Property="IsPressed" Value="True">
                                    <Setter TargetName="b" Property="Background" Value="#44FFFFFF"/>
                                </Trigger>
                            </ControlTemplate.Triggers>
                        </ControlTemplate>
                    </Button.Template>
                </Button>
            </Grid>

            <!-- 主显示 -->
            <Grid Grid.Row="1" Margin="0,6,0,0">
                <Grid.RowDefinitions>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="Auto"/>
                    <RowDefinition Height="*"/>
                </Grid.RowDefinitions>

                <TextBlock x:Name="BpmText"
                           Grid.Row="0"
                           Text="--"
                           Foreground="White"
                           FontSize="56"
                           FontWeight="Bold"
                           HorizontalAlignment="Center"/>

                <!-- Status + spinner -->
                <StackPanel Grid.Row="1"
                            Orientation="Horizontal"
                            HorizontalAlignment="Center"
                            VerticalAlignment="Center">
                    <Button x:Name="StatusBtn"
                            Content="INIT"
                            Click="StatusBtn_Click"
                            Background="Transparent"
                            BorderBrush="#33FFFFFF"
                            BorderThickness="1"
                            Padding="8,4"
                            Foreground="#99FFFFFF"
                            FontSize="13"
                            Cursor="Hand"
                            Focusable="False"
                            FocusVisualStyle="{x:Null}"
                            ContextMenuService.IsEnabled="False">
                        <Button.Style>
                            <Style TargetType="Button">
                                <Setter Property="Template">
                                    <Setter.Value>
                                        <ControlTemplate TargetType="Button">
                                            <Border x:Name="border"
                                                    Background="{TemplateBinding Background}"
                                                    BorderBrush="{TemplateBinding BorderBrush}"
                                                    BorderThickness="{TemplateBinding BorderThickness}"
                                                    CornerRadius="8"
                                                    Padding="{TemplateBinding Padding}">
                                                <ContentPresenter HorizontalAlignment="Center"
                                                                  VerticalAlignment="Center"/>
                                            </Border>
                                            <ControlTemplate.Triggers>
                                                <Trigger Property="IsEnabled" Value="False">
                                                    <Setter TargetName="border" Property="BorderBrush" Value="Transparent"/>
                                                    <Setter TargetName="border" Property="BorderThickness" Value="0"/>
                                                    <Setter TargetName="border" Property="Background" Value="Transparent"/>
                                                </Trigger>
                                                <Trigger Property="IsMouseOver" Value="True">
                                                    <Setter TargetName="border" Property="Background" Value="#11FFFFFF"/>
                                                </Trigger>
                                            </ControlTemplate.Triggers>
                                        </ControlTemplate>
                                    </Setter.Value>
                                </Setter>
                            </Style>
                        </Button.Style>
                    </Button>

                    <Grid x:Name="Spinner"
                          Width="12" Height="12"
                          Margin="6,0,0,0"
                          Visibility="Collapsed">
                        <Grid.Resources>
                            <Storyboard x:Key="SpinStoryboard" RepeatBehavior="Forever">
                                <DoubleAnimation Storyboard.TargetName="SpinnerRotate"
                                                 Storyboard.TargetProperty="Angle"
                                                 From="0" To="360"
                                                 Duration="0:0:0.8"/>
                            </Storyboard>
                        </Grid.Resources>
                        <Grid.Triggers>
                            <EventTrigger RoutedEvent="FrameworkElement.Loaded">
                                <BeginStoryboard Storyboard="{StaticResource SpinStoryboard}"/>
                            </EventTrigger>
                        </Grid.Triggers>

                        <Ellipse Stroke="#99FFFFFF"
                                 StrokeThickness="2"
                                 StrokeDashArray="1 2"
                                 Opacity="0.85"
                                 Width="12" Height="12">
                            <Ellipse.RenderTransform>
                                <RotateTransform x:Name="SpinnerRotate" CenterX="6" CenterY="6"/>
                            </Ellipse.RenderTransform>
                        </Ellipse>
                    </Grid>
                </StackPanel>

                <!-- Chart -->
                <Border x:Name="ChartHost"
                        Grid.Row="2"
                        Margin="6,8,6,6"
                        CornerRadius="10"
                        Background="#14FFFFFF"
                        BorderBrush="#22FFFFFF"
                        BorderThickness="1"
                        ClipToBounds="True">
                    <Canvas x:Name="ChartCanvas"
                            ClipToBounds="True"/>
                </Border>
            </Grid>
        </Grid>
    </Border>
</Window>


----- END FILE -----

===== FILE: D:\DATA\Kd\PJ11\Heart Beats\HeartBeats\HeartBeats\MainWindow.xaml.cs =====
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Shapes;

namespace HeartBeats;

public partial class MainWindow : Window
{
    private readonly BleHeartRateClient _hr = new();

    // 你的耳机 MAC
    private const string Mac = "C0:E2:30:5E:51:05";

    private HudSettings _settings = new();
    private bool _collapsed = false;

    // ==== Chart settings ====
    private readonly List<(DateTime t, int bpm)> _samples = new();

    private const int MinBpmFloor = 40;
    private const int MaxBpmCeil = 200;
    private const int TargetFps = 20;

    // 统一坐标系：plotRect 内画曲线/网格；padding 区域画 label
    private const double PadLeft = 30;     // 左侧：bpm 标签
    private const double PadRight = 10;    // 右侧：只留一点空间给圆点
    private const double PadTop = 10;      // 顶部
    private const double PadBottom = 14;   // 底部：时间轴数字

    private const double RightLabelGap = 4; // plotRight 到右侧数字的间隔

    private DateTime _lastRender = DateTime.MinValue;

    private volatile string _lastStatus = "INIT";
    private bool _isConnecting = false;
    private CancellationTokenSource? _connectCts;

    // GridMode: 0=Off, 1=Minimal, 2=Ticks
    private const int GridOff = 0;
    private const int GridMinimal = 1;
    private const int GridTicks = 2;

    // 动态窗口秒数
    private int WindowSeconds => ClampWindowSeconds(_settings.ChartWindowSeconds);

    private static int ClampWindowSeconds(int s)
    {
        if (s <= 40) return 30;
        if (s <= 90) return 60;
        return 120;
    }

    // ===== plot rect helper =====
    private readonly struct PlotRect
    {
        public PlotRect(double left, double top, double right, double bottom)
        {
            Left = left; Top = top; Right = right; Bottom = bottom;
        }
        public double Left { get; }
        public double Top { get; }
        public double Right { get; }
        public double Bottom { get; }
        public double Width => Math.Max(1, Right - Left);
        public double Height => Math.Max(1, Bottom - Top);
    }

    private static double PixelAlign(double v) => Math.Round(v) + 0.5;

    private PlotRect GetPlotRect(double w, double h)
    {
        double left = PadLeft;
        double right = Math.Max(left + 10, w - PadRight);
        double top = PadTop;
        double bottom = Math.Max(top + 10, h - PadBottom);
        return new PlotRect(left, top, right, bottom);
    }

    public MainWindow()
    {
        InitializeComponent();

        _hr.OnStatus += s => Dispatcher.Invoke(() => OnHrStatus(s));
        _hr.OnBpm += bpm => Dispatcher.Invoke(() =>
        {
            BpmText.Text = bpm.ToString();
            AddSample(bpm);
            TryRenderChart();
        });

        Loaded += async (_, __) =>
        {
            _settings = HudSettings.Load();
            ApplyHudSettings(_settings);

            UpdateGridMenuChecks();
            UpdateWindowMenuChecks();

            await ConnectFlowAsync(userInitiated: false);

            TryRenderChart(force: true);
        };

        Deactivated += (_, __) => SaveHudSettings();
        Closing += (_, __) => SaveHudSettings();

        Closed += async (_, __) => await _hr.DisconnectAsync();

        SizeChanged += (_, __) => TryRenderChart(force: true);
    }

    // ========= Toggle / Collapse =========

    private void ToggleBtn_Click(object sender, RoutedEventArgs e)
    {
        _collapsed = !_collapsed;
        ApplyCollapsedUi(_collapsed);
        ClampToWorkingArea();
        SaveHudSettings();
    }

    private void ApplyCollapsedUi(bool collapsed)
    {
        // 获取按钮内的箭头 Path
        var arrow = FindArrowPath();

        if (collapsed)
        {
            // 折叠：箭头向右 >
            if (arrow != null)
                arrow.Data = System.Windows.Media.Geometry.Parse("M 12,10 L 17,15 L 12,20");

            Width = 220;
            Height = 120;

            BpmText.FontSize = 40;
            BpmText.Margin = new Thickness(0, 8, 0, 6);

            ChartHost.Visibility = Visibility.Collapsed;
        }
        else
        {
            // 展开：箭头向下 v
            if (arrow != null)
                arrow.Data = System.Windows.Media.Geometry.Parse("M 10,12 L 15,17 L 20,12");

            Width = 340;
            Height = 250;

            BpmText.FontSize = 68;
            BpmText.Margin = new Thickness(0, 0, 0, 0);

            ChartHost.Visibility = Visibility.Visible;
            TryRenderChart(force: true);
        }
    }

    private System.Windows.Shapes.Path? FindArrowPath()
    {
        if (ToggleBtn.Template.FindName("arrow", ToggleBtn) is System.Windows.Shapes.Path p)
            return p;
        return null;
    }

    // ========= Samples =========

    private void AddSample(int bpm)
    {
        bpm = Math.Clamp(bpm, MinBpmFloor, MaxBpmCeil);
        var now = DateTime.UtcNow;
        _samples.Add((now, bpm));

        var cutoff = now.AddSeconds(-WindowSeconds);
        int idx = _samples.FindIndex(s => s.t >= cutoff);
        if (idx > 0) _samples.RemoveRange(0, idx);
    }

    private void TryRenderChart(bool force = false)
    {
        if (_collapsed) return;

        var now = DateTime.UtcNow;
        if (!force && (now - _lastRender).TotalMilliseconds < (1000.0 / TargetFps)) return;

        _lastRender = now;
        RenderChart();
    }


    // ========= Render =========

    private void RenderChart()
    {
        if (ChartCanvas == null || ChartHost == null) return;

        double w = Math.Max(0, ChartHost.ActualWidth);
        double h = Math.Max(0, ChartHost.ActualHeight);

        if (w <= 5 || h <= 5) return;

        ChartCanvas.Children.Clear();

        var plot = GetPlotRect(w, h);

        // 空数据：显示 "NO DATA" 文字
        if (_samples.Count < 2)
        {
            var noDataText = new TextBlock
            {
                Text = "NO DATA",
                FontSize = 14,
                Foreground = Brushes.Gray,
                Opacity = 0.5,
                HorizontalAlignment = HorizontalAlignment.Center,
                VerticalAlignment = VerticalAlignment.Center
            };
            
            noDataText.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
            double tw = noDataText.DesiredSize.Width;
            double th = noDataText.DesiredSize.Height;
            
            Canvas.SetLeft(noDataText, (w - tw) / 2);
            Canvas.SetTop(noDataText, (h - th) / 2);
            ChartCanvas.Children.Add(noDataText);
            return;
        }

        var now = DateTime.UtcNow;
        int winSec = WindowSeconds;
        var t0 = now.AddSeconds(-winSec);

        int minBpm = Math.Max(MinBpmFloor, _samples.Min(s => s.bpm));
        int maxBpm = Math.Min(MaxBpmCeil, _samples.Max(s => s.bpm));
        if (maxBpm <= minBpm) maxBpm = minBpm + 1;

        const int MinSpan = 12;
        int span = maxBpm - minBpm;
        if (span < MinSpan)
        {
            int mid = (minBpm + maxBpm) / 2;
            minBpm = mid - MinSpan / 2;
            maxBpm = mid + MinSpan / 2;
        }

        minBpm = Math.Max(MinBpmFloor, minBpm - 2);
        maxBpm = Math.Min(MaxBpmCeil, maxBpm + 2);
        if (maxBpm <= minBpm) maxBpm = minBpm + 1;

        double MapX(DateTime t)
        {
            double x = (t - t0).TotalSeconds / winSec * plot.Width;
            x = plot.Left + x;
            return Math.Clamp(x, plot.Left, plot.Right);
        }

        double MapY(int bpm)
        {
            double norm = (bpm - minBpm) / (double)(maxBpm - minBpm);
            double y = plot.Bottom - norm * plot.Height;
            return Math.Clamp(y, plot.Top, plot.Bottom);
        }

        if (_settings.GridMode == GridMinimal)
            DrawMinimalGrid(plot, minBpm, maxBpm, winSec);
        else if (_settings.GridMode == GridTicks)
            DrawTicksGrid(plot, minBpm, maxBpm, winSec);

        var poly = new Polyline
        {
            StrokeThickness = 2,
            Opacity = 0.90,
            Stroke = Brushes.White
        };

        foreach (var s in _samples)
            poly.Points.Add(new Point(MapX(s.t), MapY(s.bpm)));

        ChartCanvas.Children.Add(poly);

        var last = _samples[^1];
        double lx = MapX(last.t);
        double ly = MapY(last.bpm);

        var dot = new Ellipse
        {
            Width = 6,
            Height = 6,
            Fill = Brushes.White,
            Opacity = 0.90
        };
        Canvas.SetLeft(dot, Math.Clamp(lx - 3, plot.Left, plot.Right - 6));
        Canvas.SetTop(dot, Math.Clamp(ly - 3, plot.Top, plot.Bottom - 6));
        ChartCanvas.Children.Add(dot);

        // 去掉右侧小数字

        DrawPlotBorder(plot);
    }

    private void DrawPlotBorder(PlotRect plot)
    {
        var baseLine = new Line
        {
            X1 = plot.Left,
            Y1 = PixelAlign(plot.Bottom),
            X2 = plot.Right,
            Y2 = PixelAlign(plot.Bottom),
            Stroke = Brushes.Gray,
            StrokeThickness = 1,
            Opacity = 0.16
        };
        ChartCanvas.Children.Add(baseLine);
    }

    private void DrawRightLastValue(PlotRect plot, double canvasW, int bpm, double yAt)
    {
        var tb = new TextBlock
        {
            Text = bpm.ToString(),
            FontSize = 11,
            Foreground = Brushes.White,
            Opacity = 0.75
        };

        tb.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
        double tw = tb.DesiredSize.Width;
        double th = tb.DesiredSize.Height;

        double x = plot.Right + RightLabelGap;
        if (x + tw > canvasW - 2)
            x = Math.Max(plot.Right + 2, canvasW - 2 - tw);

        double y = Math.Clamp(yAt - th / 2, plot.Top, plot.Bottom - th);

        Canvas.SetLeft(tb, x);
        Canvas.SetTop(tb, y);
        ChartCanvas.Children.Add(tb);
    }

    // ========= Grid drawing =========

    private void DrawMinimalGrid(PlotRect plot, int minBpm, int maxBpm, int winSec)
    {
        // 使用 20%/50%/80% 更容易读取极端值
        double[] fracs = { 0.20, 0.50, 0.80 };

        foreach (var f in fracs)
        {
            double y = plot.Bottom - f * plot.Height;
            y = PixelAlign(y);

            ChartCanvas.Children.Add(new Line
            {
                X1 = plot.Left,
                Y1 = y,
                X2 = plot.Right,
                Y2 = y,
                Stroke = Brushes.Gray,
                StrokeThickness = 1,
                Opacity = 0.14
            });

            int val = (int)Math.Round(minBpm + f * (maxBpm - minBpm));
            var lb = new TextBlock
            {
                Text = val.ToString(),
                FontSize = 10,
                Foreground = Brushes.Gray,
                Opacity = 0.40  // 稍微亮一点
            };

            lb.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
            double lh = lb.DesiredSize.Height;

            double x = Math.Max(2, plot.Left - PadLeft + 2);
            // 允许标签超出 plot 区域一点，确保可见
            double ty = (y - 0.5) - lh / 2;
            ty = Math.Clamp(ty, 0, ChartCanvas.ActualHeight - lh);

            Canvas.SetLeft(lb, x);
            Canvas.SetTop(lb, ty);
            ChartCanvas.Children.Add(lb);
        }

        int tickSec = winSec switch { 30 => 10, 60 => 15, _ => 30 };
        for (int sec = tickSec; sec < winSec; sec += tickSec)
        {
            double x = plot.Left + (sec / (double)winSec) * plot.Width;
            x = PixelAlign(x);

            ChartCanvas.Children.Add(new Line
            {
                X1 = x, Y1 = plot.Top,
                X2 = x, Y2 = plot.Bottom,
                Stroke = Brushes.Gray,
                StrokeThickness = 1,
                Opacity = 0.06
            });
        }

        DrawTimeAxis(plot, winSec, dense: false);
    }

    private void DrawTicksGrid(PlotRect plot, int minBpm, int maxBpm, int winSec)
    {
        int range = Math.Max(1, maxBpm - minBpm);
        int step = range switch
        {
            <= 30 => 5,
            <= 60 => 10,
            <= 120 => 20,
            _ => 25
        };

        int start = (minBpm / step) * step;
        int end = ((maxBpm + step - 1) / step) * step;

        double MapYGrid(int bpm)
        {
            double norm = (bpm - minBpm) / (double)(maxBpm - minBpm);
            double y = plot.Bottom - norm * plot.Height;
            return y;
        }

        for (int bpm = start; bpm <= end; bpm += step)
        {
            double y = MapYGrid(bpm);
            if (y < plot.Top || y > plot.Bottom) continue;

            y = PixelAlign(y);

            ChartCanvas.Children.Add(new Line
            {
                X1 = plot.Left,
                Y1 = y,
                X2 = plot.Right,
                Y2 = y,
                Stroke = Brushes.Gray,
                StrokeThickness = 1,
                Opacity = 0.18,
                StrokeDashArray = new DoubleCollection { 3, 3 }
            });

            var label = new TextBlock
            {
                Text = bpm.ToString(),
                FontSize = 10,
                Foreground = Brushes.Gray,
                Opacity = 0.33
            };

            label.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
            double lh = label.DesiredSize.Height;

            double x = Math.Max(2, plot.Left - PadLeft + 2);
            double ty = Math.Clamp((y - 0.5) - lh / 2, plot.Top, plot.Bottom - lh);

            Canvas.SetLeft(label, x);
            Canvas.SetTop(label, ty);
            ChartCanvas.Children.Add(label);
        }

        int tickSec = winSec switch { 30 => 5, 60 => 10, _ => 20 };
        for (int sec = tickSec; sec < winSec; sec += tickSec)
        {
            double x = plot.Left + (sec / (double)winSec) * plot.Width;
            x = PixelAlign(x);

            ChartCanvas.Children.Add(new Line
            {
                X1 = x, Y1 = plot.Top,
                X2 = x, Y2 = plot.Bottom,
                Stroke = Brushes.Gray,
                StrokeThickness = 1,
                Opacity = 0.10
            });
        }

        DrawTimeAxis(plot, winSec, dense: true);
    }

    private void DrawTimeAxis(PlotRect plot, int winSec, bool dense)
    {
        int tickSec = dense
            ? (winSec switch { 30 => 5, 60 => 10, _ => 20 })
            : (winSec switch { 30 => 10, 60 => 15, _ => 30 });

        double yText = Math.Min(plot.Bottom + 2, ChartCanvas.ActualHeight - 12);

        for (int sec = 0; sec <= winSec; sec += tickSec)
        {
            double x = plot.Left + (sec / (double)winSec) * plot.Width;

            int labelVal = winSec - sec;

            var t = new TextBlock
            {
                Text = labelVal.ToString(),
                FontSize = 10,
                Foreground = Brushes.Gray,
                Opacity = dense ? 0.28 : 0.22
            };

            t.Measure(new Size(double.PositiveInfinity, double.PositiveInfinity));
            double tw = t.DesiredSize.Width;

            double tx = Math.Clamp(x - tw / 2, plot.Left, plot.Right - tw);

            Canvas.SetLeft(t, tx);
            Canvas.SetTop(t, yText);
            ChartCanvas.Children.Add(t);
        }
    }

    // ========= Drag + settings =========

    private void Card_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
    {
        if (e.ButtonState == MouseButtonState.Pressed)
            DragMove();
    }

    private void Card_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
    {
        SaveHudSettings();
    }

    private void ApplyHudSettings(HudSettings s)
    {
        _collapsed = s.Collapsed;
        ApplyCollapsedUi(_collapsed);

        if (s.Xpx != int.MinValue && s.Ypx != int.MinValue)
        {
            SetWindowPositionFromPixels(s.Xpx, s.Ypx);
            ClampToWorkingArea();
            return;
        }

        PlaceTopRightDefault();
        ClampToWorkingArea();
    }

    private void SaveHudSettings()
    {
        var rb = RestoreBounds;
        var (xpx, ypx) = DipsToPixels(rb.Left, rb.Top);

        _settings.Xpx = xpx;
        _settings.Ypx = ypx;
        _settings.Collapsed = _collapsed;

        _settings.Save();
    }

    private void PlaceTopRightDefault()
    {
        var wa = SystemParameters.WorkArea;
        Left = wa.Right - Width - 16;
        Top = wa.Top + 16;
    }

    private void ClampToWorkingArea()
    {
        var wa = SystemParameters.WorkArea;

        double maxX = wa.Right - Width;
        double maxY = wa.Bottom - Height;

        if (Left < wa.Left) Left = wa.Left;
        if (Top < wa.Top) Top = wa.Top;

        if (Left > maxX) Left = maxX;
        if (Top > maxY) Top = maxY;
    }

    private void SetWindowPositionFromPixels(int xpx, int ypx)
    {
        var (xdip, ydip) = PixelsToDips(xpx, ypx);
        Left = xdip;
        Top = ydip;
    }

    private (int xpx, int ypx) DipsToPixels(double xDip, double yDip)
    {
        var src = PresentationSource.FromVisual(this);
        if (src?.CompositionTarget == null)
            return ((int)Math.Round(xDip), (int)Math.Round(yDip));

        Matrix m = src.CompositionTarget.TransformToDevice;
        int xpx = (int)Math.Round(xDip * m.M11);
        int ypx = (int)Math.Round(yDip * m.M22);
        return (xpx, ypx);
    }

    private (double xDip, double yDip) PixelsToDips(int xPx, int yPx)
    {
        var src = PresentationSource.FromVisual(this);
        if (src?.CompositionTarget == null)
            return (xPx, yPx);

        Matrix m = src.CompositionTarget.TransformFromDevice;
        double xDip = xPx * m.M11;
        double yDip = yPx * m.M22;
        return (xDip, yDip);
    }

    // ========= Context menu =========

    private void Card_ContextMenuOpening(object sender, ContextMenuEventArgs e)
    {
        if (_collapsed)
        {
            e.Handled = true;
            return;
        }

        UpdateGridMenuChecks();
        UpdateWindowMenuChecks();
    }

    private void GridOff_Click(object sender, RoutedEventArgs e) => SetGridMode(GridOff);
    private void GridMinimal_Click(object sender, RoutedEventArgs e) => SetGridMode(GridMinimal);
    private void GridTicks_Click(object sender, RoutedEventArgs e) => SetGridMode(GridTicks);

    private void SetGridMode(int mode)
    {
        _settings.GridMode = mode;
        _settings.Save();
        UpdateGridMenuChecks();
        TryRenderChart(force: true);
    }

    private void UpdateGridMenuChecks()
    {
        if (GridOffItem != null) GridOffItem.IsChecked = _settings.GridMode == GridOff;
        if (GridMinimalItem != null) GridMinimalItem.IsChecked = _settings.GridMode == GridMinimal;
        if (GridTicksItem != null) GridTicksItem.IsChecked = _settings.GridMode == GridTicks;
    }

    private void Win30_Click(object sender, RoutedEventArgs e) => SetWindowSeconds(30);
    private void Win60_Click(object sender, RoutedEventArgs e) => SetWindowSeconds(60);
    private void Win120_Click(object sender, RoutedEventArgs e) => SetWindowSeconds(120);

    private void SetWindowSeconds(int sec)
    {
        _settings.ChartWindowSeconds = sec;
        _settings.Save();
        UpdateWindowMenuChecks();
        TryRenderChart(force: true);
    }

    private void UpdateWindowMenuChecks()
    {
        int sec = WindowSeconds;
        if (Win30Item != null) Win30Item.IsChecked = sec == 30;
        if (Win60Item != null) Win60Item.IsChecked = sec == 60;
        if (Win120Item != null) Win120Item.IsChecked = sec == 120;
    }

    // ========= Connect / Status =========

    private void OnHrStatus(string raw)
    {
        if (_isConnecting && string.Equals(raw, "DISCONNECTED", StringComparison.OrdinalIgnoreCase))
            return;

        _lastStatus = raw;

        var (display, canRetry, showSpin) = MapStatus(raw);

        if (StatusBtn != null) StatusBtn.Content = display;

        if (Spinner != null) Spinner.Visibility = (_isConnecting || showSpin) ? Visibility.Visible : Visibility.Collapsed;

        bool isLive = string.Equals(raw, "LIVE", StringComparison.OrdinalIgnoreCase);
        if (StatusBtn != null)
        {
            StatusBtn.IsEnabled = canRetry && !_isConnecting && !isLive;
            StatusBtn.Cursor = StatusBtn.IsEnabled ? Cursors.Hand : Cursors.Arrow;
            StatusBtn.Foreground = isLive ? Brushes.White : (Brush)new BrushConverter().ConvertFromString("#99FFFFFF")!;
        }
    }

    private static (string display, bool canRetry, bool showSpinner) MapStatus(string raw)
    {
        if (raw == null) return ("INIT", true, false);

        string r = raw.Trim();

        if (r.Equals("LIVE", StringComparison.OrdinalIgnoreCase))
            return ("LIVE", false, false);

        if (r.Contains("CONNECT", StringComparison.OrdinalIgnoreCase))
            return ("CONNECTING", false, true);

        if (r.Equals("DISCONNECTED", StringComparison.OrdinalIgnoreCase))
            return ("CONNECT / CLICK TO RETRY", true, false);

        if (r.Equals("DEVICE NULL", StringComparison.OrdinalIgnoreCase))
            return ("NO DEVICE / CLICK TO RETRY", true, false);

        if (r.Equals("NO HR SERVICE", StringComparison.OrdinalIgnoreCase))
            return ("NO HR SERVICE / CLICK TO RETRY", true, false);

        if (r.Equals("NO HR CHAR", StringComparison.OrdinalIgnoreCase))
            return ("NO HR CHAR / CLICK TO RETRY", true, false);

        if (r.StartsWith("SUB FAIL", StringComparison.OrdinalIgnoreCase))
            return ("SUB FAIL / CLICK TO RETRY", true, false);

        return ($"{r} / CLICK TO RETRY", true, false);
    }

    private async void StatusBtn_Click(object sender, RoutedEventArgs e)
    {
        await ConnectFlowAsync(userInitiated: true);
    }

    private async Task ConnectFlowAsync(bool userInitiated)
    {
        if (_isConnecting) return;

        _connectCts?.Cancel();
        _connectCts = new CancellationTokenSource();
        var ct = _connectCts.Token;

        _isConnecting = true;
        Dispatcher.Invoke(() => OnHrStatus("CONNECTING"));

        try
        {
            await _hr.DisconnectAsync();
            await Task.Delay(150, ct);

            for (int attempt = 1; attempt <= 3; attempt++)
            {
                ct.ThrowIfCancellationRequested();

                await _hr.ConnectAndSubscribeAsync(Mac);
                await Task.Delay(450, ct);

                if (string.Equals(_lastStatus, "LIVE", StringComparison.OrdinalIgnoreCase))
                    break;

                await Task.Delay(800, ct);
            }
        }
        catch (OperationCanceledException)
        {
            // ignore
        }
        catch (Exception ex)
        {
            Dispatcher.Invoke(() => OnHrStatus($"ERR: {ex.Message}"));
        }
        finally
        {
            _isConnecting = false;
            Dispatcher.Invoke(() => OnHrStatus(_lastStatus));
        }
    }
}



----- END FILE -----


